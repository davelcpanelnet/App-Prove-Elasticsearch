#!/usr/bin/env perl

# PODNAME: testplan
# ABSTRACT: plan testing using elasticsearch

package Bin::testplan;

use strict;
use warnings;

use Getopt::Long qw{GetOptionsFromArray};
use App::Prove::Elasticsearch::Utils;
use App::Prove::State;
use Pod::Usage;
use IO::Prompter [-yesno, -single, -stdio, -style=>'bold'];
use List::Util qw{shuffle};
use File::Basename qw{basename};
use POSIX qw{strftime};

=head1 USAGE

testplan --version blahblah --platform something -- test1 test2 test3...testN

Will create a test plan and store it in elasticsearch, supposing one does not already exist for the passed version.
Will also queue tests if a non-default Queue module is configured in elastest.conf.

In the event a plan matching your platform(s) and version is found, tests passed but not found in the plan will be added.
Similarly, tests found in the plan but not passed will be removed.

If no platform(s) are provided, the configured (or default) platformer class will be used.

The basename of the tests passed will be used to identify 'what tests need to be run', so be sure to name your tests uniquely.

Tests passed which cannot be found will be ignored.
If no tests are passed, any tests in t/ will be used by default.

=head2 optional switches

--show - display the proposed plan instead of creating it, and whether or not it already exists (or will be modified by passed arguments).

--prompt - display proposed modifications to a plan (if any) will be made on the server.

--pairwise - If configured with platform groups (see below), consider the plan satisfied if each platform passed appears at least once.
In the event that a plan update is made, tests will be properly apportioned upon update.

--all-platforms - If configured with platform groups, use all those available rather than passing manually with --platform.

--name - If you want to differentiate your run from others with the same versions/platforms, use this.

--recurse - if passing directories of tests, recurse past the first level to find tests.

--extension - If passing directories, check for tests with these extensions.  May be passed multiple times, defaults to t

--requeue - Re-queue an existing plan, in case something didn't quite work out.  Use to suppress prompts about re-queueing in --prompt mode.

=head1 CONFIGURATION

Aside from the usual configuration from L<App::Prove::Plugin::Elasticsearch>,
you can add a new section to describe mutually exclusive platforms (combinations, for my fellow math geeks out there).

It would look something like this:

    [PlatformGroups]
    Operating Systems = CentOS 7 64-bit,CentOS 6 32-bit
    Browsers = Firefox,Chrome
    Interpreters = Perl 5.14,Perl 5.16

And result in plans specifying multiple platforms within the same group requiring the test be run at least once on all said platforms.
For example, a plan created asking for all the above platforms would result in the following 8 runs being needed (2^3):

=over 4

=item CentOS 7 64-bit on Firefox using Perl 5.14

=item CentOS 7 64-bit on Firefox using Perl 5.16

=item CentOS 6 64-bit on Firefox using Perl 5.14

=item CentOS 6 64-bit on Firefox using Perl 5.16

=item CentOS 7 64-bit on Chrome using Perl 5.14

=item CentOS 7 64-bit on Chrome using Perl 5.16

=item CentOS 6 64-bit on Chrome using Perl 5.14

=item CentOS 6 64-bit on Chrome using Perl 5.16

=back

In general, the number of runs you will be required to execute to satisfy the plan will be $num_groups_represented * $num_groups_provided.

=head2 PAIRWISE TESTING

Were you to pass --pairwise, we would randomly mix the configurations to be something like so:

=over 4

=item CentOS 6 64-bit on Firefox using Perl 5.14

=item CentOS 7 64-bit on Chrome using Perl 5.16

=back

This way you would get all your supported platforms tested, but with less testing effort.
Over successive verisons you would cover all the 8 combinations above eventually.

Supposing you have no platform groups defined, it is assumed that no platform is mutually exclusive;
therefore only one run would be required, supposing it satisfied all the provided platforms.

Furthermore, the tests provided will be evenly apportioned amongst the sets of platforms produced, to further expedite testing.

=head1 EXTENSIBILITY

As with all the other utilities here, the backend used to store test plans is extensible by specifying the planner class in elastest.conf.

Setting client.planner=SomeClass

would correspond to App::Prove::Elasticsearch::Planner::SomeClass being loaded and used as the planner backend.

See L<App::Prove::Elasticsearch::Planner::Default> as a template for making planner classes.

=cut

exit main(@ARGV) unless caller;

sub main {
    my @args = @_;

    my (%options,@conf, $help);
    GetOptionsFromArray(
        \@args,
        'platform=s@'   => \$options{platforms},
        'version=s'     => \$options{version},
        'show'          => \$options{show},
        'prompt'        => \$options{prompt},
        'pairwise'      => \$options{pairwise},
        'all-platforms' => \$options{allplatforms},
        'recurse'       => \$options{recurse},
        'extension=s@'  => \$options{exts},
        'name'          => \$options{name},
        'requeue'       => \$options{requeue},
        'help'          => \$help,
    );
    $options{platforms} //= [];

    #Deliberately exiting here, as I "unit" test this as the binary
    pod2usage(0) if $help;

    if (!$options{version}) {
        pod2usage(
            -exitval => "NOEXIT",
            -msg     => "Insufficient arguments.  You must pass --version.",
        );
        return 2;
    }

    if ($options{prompt} && $options{show} ) {
        pod2usage(
            -exitval => "NOEXIT",
            -msg     => "--prompt and --show are mutually exclusive options.  You must pass one or the other.",
        );
        return 3;
    }

    #Store platform groups in the configuration to differentiate further plans
    my $conf = App::Prove::Elasticsearch::Utils::process_configuration(@conf);

    if (scalar(grep { my $subj = $_; grep { $subj eq $_ } qw{server.host server.port} } keys(%$conf)) != 2 ) {
        pod2usage(
            -exitval => "NOEXIT",
            -msg => "Insufficient information provided to associate defect with test results to elasticsearch",
        );
        return 4;
    }

    #Use Prove's arg parser to grab tests & globs correctly
    my $proveState = App::Prove::State->new();
    $proveState->extensions($options{exts}) if $options{exts};
    my @tests_filtered = $proveState->get_tests( $options{'recurse'}, @args );
    @args = map { basename $_ } grep { -f $_ }  @tests_filtered;

    #default platforms to whatever platformer can figure out
    if (!scalar(@{$options{platforms}}) && !$options{allplatforms} ) {
        my $platformer = App::Prove::Elasticsearch::Utils::require_platformer($conf);
        $options{platforms} = &{ \&{$platformer . "::get_platforms"} }();
    }

    my $planner = App::Prove::Elasticsearch::Utils::require_planner($conf);
    &{ \&{$planner . "::check_index"} }($conf);

    my @plans = _build_plans($planner,$conf,\@args,%options);

    my $queue = App::Prove::Elasticsearch::Utils::require_queue($conf);
    my $q = &{ \&{$queue . "::new"} }($queue,\@conf);

    my $global_result = 0;
    my $queue_result  = 0;
    foreach my $plan (@plans) {

        if ($options{show}) {
            _print_plan($plan,1);
            next;
        }
        if ($options{prompt}) {
            _print_plan($plan);
            if (!$plan->{noop}) {
                prompt( "Do you want to enact the above changes?" ) or next;
            } else {
                ( prompt( "Do you want to re-queue the plan?" ) or next ) unless $options{requeue};
                $queue_result  += $q->queue_jobs($plan);
                next;
            }
        }
        $global_result += &{ \&{$planner . "::add_plan_to_index"} }($plan);
        $queue_result  += $q->queue_jobs($plan) if !$plan->{noop} || $options{requeue};
    }
    print "$global_result plans failed to be created, examine above output\n" if $global_result;
    print "$queue_result plans failed to be queued, examine above output\n"   if $queue_result;
    return $global_result ? 2 : 0;

}

sub _build_plans {
    my ($planner,$conf,$tests,%options) = @_;

    my @plans;
    my @pgroups = grep { $_ =~ m/PlatformGroups/ } keys(%$conf);

    #filter groups by what we actually passed, if we have any
    if (scalar(@{$options{platforms}}) && !$options{allplatforms} ) {

        foreach my $grp (@pgroups) {
            @{$conf->{$grp}} = grep { my $grp = $_; grep { $grp eq $_ } @{$options{platforms}}; } @{$conf->{$grp}};
            delete $conf->{$grp} unless scalar(@{$conf->{$grp}});
        }
        @pgroups = grep { $_ =~ m/PlatformGroups/ } keys(%$conf);
    }

    if (scalar(@pgroups)) {
        #break out the groups depending if we are pairwise or not
        if ($options{pairwise}) {
            #Randomize execution order
            @$tests = shuffle(@$tests);

            # The idea here is to have at least one pigeon in each hole.
            # This is accomplished by finding the longest list of groups, and then iterating over everything we have modulo their size.
            my $longest;
            foreach my $pgroup (@pgroups) {
                $longest ||= $pgroup;
                $longest = $pgroup if scalar(@{$conf->{$pgroup}}) > scalar(@{$conf->{$longest}});
            }

            my @last_tests_apportioned;
            for (my $i=0; $i < scalar(@{$conf->{$longest}}); $i++) {
                my %cloned = %options;
                my @newplats;
                foreach my $pgroup (@pgroups) {
                    my $idx = $i % scalar(@{$conf->{$pgroup}});
                    push(@newplats,$conf->{$pgroup}->[$idx]);
                }
                $cloned{platforms} = \@newplats;

                #Figure out how many tests to dole out to the run
                my @tests_apportioned;
                my $tests_picked = int(scalar(@$tests) / scalar(@{$conf->{$longest}}) );
                for my $j (0..$tests_picked) {
                    my $picked = shift @$tests;
                    push(@tests_apportioned,$picked) if $picked;
                }

                #Handle the corner case where we are passed less tests than we have platforms
                @tests_apportioned = @last_tests_apportioned if !scalar(@tests_apportioned);
                @last_tests_apportioned = @tests_apportioned;

                push(@plans,_build_plan($planner,\@tests_apportioned,%cloned));
            }
        } else {

            #construct iterator
            my $num_combinations=1;
            my @pigeonholes = map {
                $conf->{$_}
            } @pgroups;

            my @iterator = @{$pigeonholes[0]};
            while (scalar(@iterator) ) {
                my $subj = shift @iterator;

                #Handle initial elements
                $subj = [$subj] if ref $subj ne 'ARRAY';

                #Break out of the loop if we have no more possibilities to exploit
                if (scalar(@$subj) == scalar(@pigeonholes)) {
                    my %cloned = %options;
                    $cloned{platforms} = $subj;
                    push(@plans,_build_plan($planner,$tests,%cloned));
                    next;
                }

                #Keep pushing partials on to the end of the iterator, until we run out of categories to add
                foreach my $element (@{$pigeonholes[scalar(@$subj)]}) {
                    my @partial = @$subj;
                    push(@partial,$element);
                    push(@iterator,\@partial);
                }
            }

        }
    } else {
        push(@plans,_build_plan($planner,$tests,%options));
    }

    #TODO inject creator & created time into plans
    @plans = map { $_->{created} = strftime("%Y-%m-%d %H:%M:%S",localtime()); $_ } @plans;

    return @plans;
}

sub _build_plan {
    my ($planner,$tests,%options) = @_;
    $options{tests} = $tests;

    #First, see if we already have a plan like this.
    my $existing = &{ \&{$planner . "::get_plan"} }(%options);

    #If not, make the plan.  Otherwise, construct the update statements needed to 'make it so'.
    if (!$existing) {
        $existing = &{ \&{$planner . "::make_plan"} }(%options);
    } else {
        $existing = &{ \&{$planner . "::make_plan_update"} }($existing,%options);
    }

    return $existing;
}

sub _print_plan {
    my ($plan,$force) = @_;
    if (!$plan->{noop} || $force) {
        require Data::Dumper;
        print "Plan already exists:\n";
        print "=========================\n";
        print Data::Dumper::Dumper($plan);
    } else {
        print "Plan already exists, and no updates will be made.\n";
    }
}

1;

__END__


