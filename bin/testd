#!/usr/bin/env perl

# PODNAME: testd
# ABSTRACT: watch for tests needing running and run them

package Testd;

use strict;
use warnings;

use POSIX qw{setsid};

use App::Prove::Elasticsearch::Utils;
use MCE::Loop;
use MCE::Signal qw(-setpgrp);

our $interval = 30;

main() unless caller();

=head1 USAGE

testd

Requires that you have a configured autodiscover value in your ~/elastest.conf.

=head1 SUBROUTINES

=head2 main

Runs the program and parses arguments.

=cut

sub main {

	my $conf = App::Prove::Elasticsearch::Utils::process_configuration();

	#my $pid = daemonify() or die "Could not daemonize";
	#print "Spawned as PID $pid\n";

    my $queue = App::Prove::Elasticsearch::Utils::require_queue($conf);
    my $q = &{ \&{$queue . "::new"} }($queue);
    $conf->{'testd.max_workers'} ||= 1;

    MCE::Loop::init {
        max_workers => $conf->{'testd.max_workers'},
        chunk_size  => 1,
    };

    my %ret = mce_loop {
        my $tests = $_;
        MCE->gather( worker($conf,$q) );
    }
    $tests_queue;
}

=head2 worker($conf,$queue)

The worker process, which will grab some jobs and then run them.
The caller should fork before executing this.

=cut

sub worker {
    my ($conf,$q) = @_;
	my $msg = "testd - worker ".MCE->wid().":";
	$0 = "$msg starting up";

	my $jobspec = {};
	my $platformer = App::Prove::Elasticsearch::Utils::require_platformer($conf);
	$jobspec->{platforms} = &{ \&{$platformer . "::get_platforms"} }();

	my $versioner = App::Prove::Elasticsearch::Utils::require_versioner($conf);
	$jobspec->{version} = &{ \&{$versioner . "::get_version"} }("$ENV{PWD}/t/bogus.t"); #XXX this will cause trouble with other versioners & planners, I'm sure

	$jobspec->{queue_name} = $q->build_queue_name($jobspec);

	while (1) {
		$0 = "$msg looking for jobs";
		my @jobs = $q->get_jobs($jobspec);
		if (!@jobs) {
			$0 = "$msg waiting for jobs";
			sleep $interval;
			next;
		}
		$0 = "$msg running tests";
	    my $runner = App::Prove::Elasticsearch::Utils::require_runner($conf);
		&{ \&{$runner . "::run"} }($conf,@jobs);
	}
	return 0;
}

=head2 daemonify

I am purposely not having a PIDFile, logging or any other facilities you can get with start-stop-daemon.
A service file will be provided in /service.

=cut

sub daemonify {
    my ( $test_only ) = @_;    # Flag for unit tests. Unfortunately there's not much other way I can safely test this in a unit test (that I can figure out anyways).
    $test_only //= 0;

    my $pid;
    unless ($test_only) {    # uncoverable branch true
        $pid = fork;
        exit 0 if $pid;
        exit 1 if !defined($pid);
        setsid();
        $pid = fork;
        exit 0 if $pid;
        exit 1 if not defined $pid;
        chdir '/' or die $!;
        umask 0;
		$pid = $$;
    }
    return $pid;
}

1;

__END__
